configurations {
    jacoco
    jacocoRuntime
}

jacoco {
    toolVersion = "0.8.6"
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

def coverageSourceDir = 'src/java/'

def classDir = "$buildDir.path/intermediates/javac/debug/classes"
def offlineInstrOutDir = "$buildDir.path/intermediates/javac/debug/classes-instrumented"

def execInstrumented = "$buildDir.path/jacoco/testDebugUnitTest.exec"


task jacocoTestReport(type: JacocoReport, dependsOn: 'createOfflineTestCoverageReport') {
    getClassDirectories().setFrom(
        fileTree(
            dir: classDir,
            excludes: [
                '**/R.class',
                '**/R$*.class',
                '**/BuildConfig.*',
                '**/MainActivity.*',
                '**/*$Stub*',
                '**/CpuComServiceLog*',
                '**/CpuComServiceCsvGenerator*'
        ])
    )

    reports {
        xml.enabled  true
        html.enabled  true
    }

    getSourceDirectories().setFrom(files(coverageSourceDir))
    getExecutionData().setFrom(files('build/jacoco/testDebugUnitTest.exec'))
}

/**
 * This task is used to create offline instrumentation of classes for on-the-fly instrumentation
 * coverage tool like Jacoco. See "jacoco classId"  and "Offline Instrumentation" from the jacoco
 * site for more info.
 *
 * In this case, some classes mocked using PowerMock were reported as 0% coverage on jacoco &
 * Sonarqube. The issue between PowerMock and jacoco  is well documented, and a possible solution
 * is offline Instrumentation (not so well documented for gradle).
 *
 * In a nutshell, this task:
 *  - Pre-instruments the original *.class files.
 *  - Puts the instrumented classes path at the beginning of the task's classpath (for report
 *  purposes).
 *  - Runs test & generates a new exec file based on the pre-instrumented classes -- as opposed
 *  to on-the-fly instrumented class files generated by jacoco.
 *
 * It is currently not implemented to run prior to any other existing tasks (like test,
 * jacocoTestReport, etc...), therefore, it should be called explicitly if Offline
 * Instrumentation report is needed.
 *
 *  Usage: ./gradlew clean build test; ./gradlew createOfflineTestCoverageReport jacocoTestReport
 */
task createOfflineTestCoverageReport(dependsOn: ['instrument', 'testDebugUnitTest']) {
    doLast {
        ant.taskdef(name: 'report',
                classname: 'org.jacoco.ant.ReportTask',
                classpath: configurations.jacocoAnt.asPath)
        ant.report() {
            executiondata {
                ant.file(file: execInstrumented)
            }
            structure(name: 'Example') {
                classfiles {
                    fileset(dir: classDir)
                }
                sourcefiles {
                    fileset(dir: coverageSourceDir)
                }
            }
        }
    }
}

/**
 * Instruments the classes per se
 */
task instrument(dependsOn:'compileDebugUnitTestSources') {
    doLast {
        println 'Instrumenting classes'

        ant.taskdef(name: 'instrument',
                classname: 'org.jacoco.ant.InstrumentTask',
                classpath: configurations.jacocoAnt.asPath)

        ant.instrument(destdir: offlineInstrOutDir) {
            fileset(dir: classDir)
        }
    }
}

/**
 * Part of the Offline Instrumentation process is to add the jacoco runtime to the class path
 * along with the path of the instrumented files.
 */
gradle.taskGraph.whenReady { graph ->
    if (graph.hasTask(instrument)) {
        tasks.withType(Test) {
            doFirst {
                systemProperty 'jacoco-agent.destfile', execInstrumented
                classpath = files(offlineInstrOutDir) + classpath + configurations.jacocoRuntime
            }
        }
    }
}